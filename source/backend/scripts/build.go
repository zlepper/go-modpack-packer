// Builds the releases

package main

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"text/template"
)

type configuration struct {
	OS        string
	Arch      string
	Extension string
}

var (
	configurations []configuration = []configuration{
		{
			OS:        "windows",
			Arch:      "386",
			Extension: "windows-x32.exe",
		},
		{
			OS:        "windows",
			Arch:      "amd64",
			Extension: "windows-x64.exe",
		},
		{
			OS:        "darwin",
			Arch:      "386",
			Extension: "osx-x32",
		},
		{
			OS:        "darwin",
			Arch:      "amd64",
			Extension: "osx-x64",
		},
		{
			OS:        "linux",
			Arch:      "386",
			Extension: "linux-x32",
		},
		{
			OS:        "linux",
			Arch:      "amd64",
			Extension: "linux-x64",
		},
	}
)

func main() {

	embedOnly := flag.Bool("embedOnly", false, "Set to true to only generate embeding")

	flag.Parse()

	if *embedOnly {
		embedFrontend()
	} else {
		buildFrontend()
		embedFrontend()

		log.Println("Starting build")
		goBinary, err := exec.LookPath("go")
		if err != nil {
			log.Panicln(err)
		}

		var wg sync.WaitGroup
		wg.Add(len(configurations))
		for _, conf := range configurations {
			go func(conf configuration) {
				log.Printf("building binary for '%s'\n", conf.Extension)
				cmd := exec.Cmd{
					Path: goBinary,
					Args: []string{
						goBinary,
						"build",
						"-o",
						fmt.Sprintf("build/modpack-packer-%s", conf.Extension),
						"github.com/zlepper/go-modpack-packer/source/backend",
					},
					Env: append(
						os.Environ(),
						fmt.Sprintf("GOOS=%s", conf.OS),
						fmt.Sprintf("GOARCH=%s", conf.Arch),
					),
				}
				output, err := cmd.CombinedOutput()
				if err != nil {
					log.Println("build args", cmd.Args)
					log.Println("Error when building", err, "\n", string(output))
					return
				}
				log.Printf("Successfully build binary for '%s'\n", conf.Extension)
				wg.Done()
			}(conf)
		}
		wg.Wait()
		log.Println("Finished building all configurations.")
	}
}

type filecontent struct {
	Name        string
	Content     string
	IsMap       bool
	ContentType string
}

type templateInput struct {
	Files        []filecontent
	IndexContent string
}

const (
	templateCode = `// Code generated by scripts/frontend.go DO NOT EDIT.
package main

import (
	"github.com/labstack/echo"
	"net/http"
	"io/ioutil"
	"path"
	"log"
	"encoding/base64"
)

// Allows access to all the frontend files, now embedded in the application
func bindFiles(e *echo.Echo) {
	{{range .Files}}
	{{if not .IsMap}}
	{
		bin, err := base64.StdEncoding.DecodeString("{{.Content}}")
		if err != nil {
			log.Panicln(err)
		}
		e.GET("/{{.Name}}", func(c echo.Context) error {
			c.Response().Header().Add("Content-Encoding", "gzip")
			return c.Blob(http.StatusOK, "{{.ContentType}}", bin)
		})
	}
	{{end}}
	{{end}}

	e.GET("/", func(c echo.Context) error {
		return c.HTML(http.StatusOK, {{.IndexContent}})
	})

	echo.NotFoundHandler = func(c echo.Context) error {
		println("Not found handler called")
		return c.HTML(http.StatusOK, {{.IndexContent}})
	}

	println("Not found handlers attached")
}

func loadContent(s string) []byte {
	content, err := ioutil.ReadFile(path.Join("..", "frontend", "dist", s))
	if err != nil {
		return make([]byte, 0)
	}
	return content
}

func bindNonInline(e *echo.Echo) {

	{{range .Files}}
	e.GET("/{{.Name}}", func(c echo.Context) error {
		return c.Blob(http.StatusOK, "{{.ContentType}}", loadContent("{{.Name}}"))
	})
	{{end}}

	e.GET("/", func(c echo.Context) error {
		return c.HTML(http.StatusOK, string(loadContent("index.html")))
	})

	echo.NotFoundHandler = func(c echo.Context) error {
		println("Not found handler called")
		return c.HTML(http.StatusOK, string(loadContent("index.html")))
	}

}
	`
)

func embedFrontend() {

	log.Println("Embedding frontend")

	ti := templateInput{}

	dir := path.Join("..", "frontend", "dist")
	fs, _ := ioutil.ReadDir(dir)
	for _, f := range fs {
		filename := f.Name()
		content, _ := ioutil.ReadFile(path.Join(dir, filename))

		if strings.HasSuffix(filename, ".js") ||
			strings.HasSuffix(filename, ".js.map") ||
			strings.HasSuffix(filename, ".css") ||
			strings.HasSuffix(filename, ".css.map") {

			// We need the output to be base64 encoded
			var buf bytes.Buffer
			encoder := base64.NewEncoder(base64.StdEncoding, &buf)

			zipWriter := gzip.NewWriter(encoder)
			zipWriter.Name = filename
			_, err := zipWriter.Write(content)
			if err != nil {
				panic(err)
			}
			if err = zipWriter.Close(); err != nil {
				panic(err)
			}

			isMap := strings.HasSuffix(filename, ".map")

			contentType := "application/octet-stream"
			if strings.HasSuffix(filename, ".js") {
				contentType = "application/javascript"
			} else if strings.HasSuffix(filename, ".css") {
				contentType = "text/css"
			}

			ti.Files = append(ti.Files, filecontent{Name: filename, Content: buf.String(), IsMap: isMap, ContentType: contentType})
		}
		if filename == "index.html" {
			s := strconv.Quote(string(content))
			ti.IndexContent = s
		}
	}

	out, err := os.Create("hosting.go")
	if err != nil {
		panic(err)
	}
	defer out.Close()

	tmpl, _ := template.New("hosting").Parse(templateCode)

	tmpl.Execute(out, ti)

}

func buildFrontend() {
	log.Println("building frontend")

	// Find the frontend directory
	dir, _ := os.Getwd()
	dir, _ = filepath.Abs(dir)
	dir = strings.Replace(dir, "\\", "/", -1)
outer:
	for {
		subdirs, _ := ioutil.ReadDir(dir)
		for _, subdir := range subdirs {
			if subdir.IsDir() && subdir.Name() == "frontend" {
				dir = path.Join(dir, subdir.Name())
				break outer
			}
		}
		upperDir := path.Dir(dir)
		if upperDir == dir {
			panic("Could not find frontend dir")
		}
		dir = upperDir
	}

	log.Println("Frontend dir", dir)

	angularBinary, err := exec.LookPath("ng")
	if err != nil {
		panic(err)
	}

	cmd := exec.Cmd{
		Path: angularBinary,
		Args: []string{
			angularBinary,
			"build",
			"--prod",
			"--aot",
		},
		Dir: dir,
	}
	output, err := cmd.CombinedOutput()
	if err != nil {
		println(string(output))
		panic(err)
	}
}
