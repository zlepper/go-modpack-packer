package main

// Replaces the content of index.html with inlined scripts instead of links,
// and outputs it as hosting.go, in the root of the backend project.
// This way to embed things, and only have to distribute one binary.

import (
	"io/ioutil"
	"os"
	"path"

	"strconv"
	"strings"
	"text/template"
)

type filecontent struct {
	Name    string
	Content string
}

type templateInput struct {
	Files        []filecontent
	IndexContent string
}

const (
	templateCode = `// Code generated by scripts/frontend.go DO NOT EDIT.
package main

import (
	"github.com/labstack/echo"
	"net/http"
	"io/ioutil"
	"path"
)

// Allows access to all the frontend files, now embedded in the application
func bindFiles(e *echo.Echo) {
	{{range .Files}}
	e.GET("/{{.Name}}", func(c echo.Context) error {
		return c.String(http.StatusOK, {{.Content}})
	})
	{{end}}

	e.GET("/", func(c echo.Context) error {
		return c.HTML(http.StatusOK, {{.IndexContent}})
	})

	echo.NotFoundHandler = func(c echo.Context) error {
		println("Not found handler called")
		return c.HTML(http.StatusOK, {{.IndexContent}})
	}

	println("Not found handlers attached")
}

func loadContent(s string) string {
	content, err := ioutil.ReadFile(path.Join("..", "frontend", "dist", s))
	if err != nil {
		return ""
	}
	return string(content)
}

func bindNonInline(e *echo.Echo) {

	{{range .Files}}
	e.GET("/{{.Name}}", func(c echo.Context) error {
		return c.String(http.StatusOK, loadContent("{{.Name}}"))
	})
	{{end}}

	e.GET("/", func(c echo.Context) error {
		return c.HTML(http.StatusOK, loadContent("index.html"))
	})

	echo.NotFoundHandler = func(c echo.Context) error {
		println("Not found handler called")
		return c.HTML(http.StatusOK, loadContent("index.html"))
	}

}
	`
)

func main() {

	ti := templateInput{}

	dir := path.Join("..", "frontend", "dist")
	fs, _ := ioutil.ReadDir(dir)
	for _, f := range fs {
		filename := f.Name()
		content, _ := ioutil.ReadFile(path.Join(dir, filename))
		if strings.HasSuffix(filename, ".js") ||
			strings.HasSuffix(filename, ".js.map") ||
			strings.HasSuffix(filename, ".css") ||
			strings.HasSuffix(filename, ".css.map") {
			s := strconv.Quote(string(content))
			ti.Files = append(ti.Files, filecontent{Name: filename, Content: s})
		}
		if filename == "index.html" {
			s := strconv.Quote(string(content))
			ti.IndexContent = s
		}
	}

	out, err := os.Create("hosting.go")
	if err != nil {
		panic(err)
	}
	defer out.Close()

	tmpl, _ := template.New("hosting").Parse(templateCode)

	tmpl.Execute(out, ti)

}
