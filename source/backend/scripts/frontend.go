package main

// Replaces the content of index.html with inlined scripts instead of links,
// and outputs it as hosting.go, in the root of the backend project.
// This way to embed things, and only have to distribute one binary.

import (
	"io/ioutil"
	"os"
	"path"

	"bytes"
	"compress/gzip"
	"encoding/base64"
	"strconv"
	"strings"
	"text/template"
)

type filecontent struct {
	Name    string
	Content string
	IsMap   bool
}

type templateInput struct {
	Files        []filecontent
	IndexContent string
}

const (
	templateCode = `// Code generated by scripts/frontend.go DO NOT EDIT.
package main

import (
	"github.com/labstack/echo"
	"net/http"
	"io/ioutil"
	"path"
	"log"
	"encoding/base64"
)

// Allows access to all the frontend files, now embedded in the application
func bindFiles(e *echo.Echo) {
	{{range .Files}}
	{{if not .IsMap}}
	{
		bin, err := base64.StdEncoding.DecodeString("{{.Content}}")
		if err != nil {
			log.Panicln(err)
		}
		e.GET("/{{.Name}}", func(c echo.Context) error {
			c.Response().Header().Add("Content-Encoding", "gzip")
			return c.Blob(http.StatusOK, "", bin)
		})
	}
	{{end}}
	{{end}}

	e.GET("/", func(c echo.Context) error {
		return c.HTML(http.StatusOK, {{.IndexContent}})
	})

	echo.NotFoundHandler = func(c echo.Context) error {
		println("Not found handler called")
		return c.HTML(http.StatusOK, {{.IndexContent}})
	}

	println("Not found handlers attached")
}

func loadContent(s string) string {
	content, err := ioutil.ReadFile(path.Join("..", "frontend", "dist", s))
	if err != nil {
		return ""
	}
	return string(content)
}

func bindNonInline(e *echo.Echo) {

	{{range .Files}}
	e.GET("/{{.Name}}", func(c echo.Context) error {
		return c.String(http.StatusOK, loadContent("{{.Name}}"))
	})
	{{end}}

	e.GET("/", func(c echo.Context) error {
		return c.HTML(http.StatusOK, loadContent("index.html"))
	})

	echo.NotFoundHandler = func(c echo.Context) error {
		println("Not found handler called")
		return c.HTML(http.StatusOK, loadContent("index.html"))
	}

}
	`
)

func main() {

	ti := templateInput{}

	dir := path.Join("..", "frontend", "dist")
	fs, _ := ioutil.ReadDir(dir)
	for _, f := range fs {
		filename := f.Name()
		content, _ := ioutil.ReadFile(path.Join(dir, filename))

		if strings.HasSuffix(filename, ".js") ||
			strings.HasSuffix(filename, ".js.map") ||
			strings.HasSuffix(filename, ".css") ||
			strings.HasSuffix(filename, ".css.map") {

			// We need the output to be base64 encoded
			var buf bytes.Buffer
			encoder := base64.NewEncoder(base64.StdEncoding, &buf)

			zipWriter := gzip.NewWriter(encoder)
			zipWriter.Name = filename
			_, err := zipWriter.Write(content)
			if err != nil {
				panic(err)
			}
			if err = zipWriter.Close(); err != nil {
				panic(err)
			}

			isMap := strings.HasSuffix(filename, ".map")

			ti.Files = append(ti.Files, filecontent{Name: filename, Content: buf.String(), IsMap: isMap})
		}
		if filename == "index.html" {
			s := strconv.Quote(string(content))
			ti.IndexContent = s
		}
	}

	out, err := os.Create("hosting.go")
	if err != nil {
		panic(err)
	}
	defer out.Close()

	tmpl, _ := template.New("hosting").Parse(templateCode)

	tmpl.Execute(out, ti)

}
